#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>
#include <limits>

using namespace std;

struct Course {
    string id;
    string name;
    string location;
    int credit;
    int day;    // Day of week (1=Mon, 2=Tue,...)
    int start;  // Start time slot
    int end;    // End time slot
};

// Check if two courses conflict in schedule
bool conflict(const Course& a, const Course& b) {
    return (a.day == b.day && !(a.end <= b.start || b.end <= a.start));
}

// Scoring function: preferences + time compactness + location proximity
int calcScore(const vector<Course>& chosen, const vector<string>& prefList) {
    int score = 0;

    // 1. Preference coverage
    for (const auto& c : chosen) {
        if (find(prefList.begin(), prefList.end(), c.id) != prefList.end()) {
            score += 10;
        }
    }

    // 2. Time compactness (less gaps = higher score)
    for (int day = 1; day <= 7; day++) {
        vector<Course> daily;
        for (const auto& c : chosen) if (c.day == day) daily.push_back(c);
        if (daily.size() <= 1) continue;

        sort(daily.begin(), daily.end(), [](auto& a, auto& b){ return a.start < b.start; });
        for (size_t i = 1; i < daily.size(); i++) {
            int gap = daily[i].start - daily[i-1].end;
            if (gap == 0) score += 5;       // Back-to-back
            else if (gap <= 2) score += 2;  // Small gap
            else score -= gap;              // Large gap penalty
        }
    }

    // 3. Location proximity (same building = bonus, different = penalty)
    for (size_t i = 0; i < chosen.size(); i++) {
        for (size_t j = i+1; j < chosen.size(); j++) {
            if (chosen[i].day == chosen[j].day) {
                if (chosen[i].location == chosen[j].location) score += 3;
                else score -= 1;
            }
        }
    }

    return score;
}

struct Solution {
    int score;
    vector<Course> schedule;
};

// Backtracking with pruning
void backtrack(int idx, int curCredit, int creditLimit,
               const vector<Course>& courses,
               vector<Course>& current, vector<Solution>& solutions,
               const vector<string>& prefList) {
    if (curCredit > creditLimit) return; // prune: exceed credits

    if (idx == (int)courses.size()) {
        int sc = calcScore(current, prefList);
        solutions.push_back({sc, current});
        return;
    }

    // Option 1: take this course (if no conflict)
    bool ok = true;
    for (auto& c : current) {
        if (conflict(c, courses[idx])) {
            ok = false; break;
        }
    }
    if (ok) {
        current.push_back(courses[idx]);
        backtrack(idx+1, curCredit + courses[idx].credit,
                  creditLimit, courses, current, solutions, prefList);
        current.pop_back();
    }

    // Option 2: skip this course
    backtrack(idx+1, curCredit, creditLimit, courses, current, solutions, prefList);
}

// Read courses from file (format: id name location credit day start end)
vector<Course> readCoursesFromFile(const string& filename) {
    vector<Course> courses;
    ifstream fin(filename);
    if (!fin.is_open()) {
        cerr << "Cannot open file " << filename << endl;
        return courses;
    }
    string id, name, location;
    int credit, day, start, end;
    while (fin >> id >> name >> location >> credit >> day >> start >> end) {
        courses.push_back({id, name, location, credit, day, start, end});
    }
    return courses;
}

int main() {
    int creditLimit, K, mode;
    cout << "Enter credit limit: ";
    cin >> creditLimit;
    cout << "Enter how many top schedules to output (K): ";
    cin >> K;
    cout << "Choose input mode (1=manual input, 2=from file): ";
    cin >> mode;

    vector<Course> courses;
    if (mode == 1) {
        int n;
        cout << "Enter number of courses: ";
        cin >> n;
        for (int i = 0; i < n; i++) {
            Course c;
            cout << "Enter course (id name location credit day start end): ";
            cin >> c.id >> c.name >> c.location >> c.credit >> c.day >> c.start >> c.end;
            courses.push_back(c);
        }
    } else {
        string fname;
        cout << "Enter filename (e.g. courses.txt): ";
        cin >> fname;
        courses = readCoursesFromFile(fname);
    }

    // Preferred courses
    vector<string> prefList;
    cout << "Enter number of preferred courses: ";
    int m; cin >> m;
    cout << "Enter preferred course ids: ";
    for (int i = 0; i < m; i++) {
        string s; cin >> s;
        prefList.push_back(s);
    }

    // Backtracking search
    vector<Solution> solutions;
    vector<Course> current;
    backtrack(0, 0, creditLimit, courses, current, solutions, prefList);

    // Sort solutions by score
    sort(solutions.begin(), solutions.end(),
         [](auto& a, auto& b){ return a.score > b.score; });

    // Output top K schedules
    int count = min(K, (int)solutions.size());
    for (int i = 0; i < count; i++) {
        cout << "Schedule " << (i+1) << " (score=" << solutions[i].score << "):\n";
        for (auto& c : solutions[i].schedule) {
            cout << "  " << c.id << " " << c.name
                 << " Credit:" << c.credit
                 << " Location:" << c.location
                 << " Day" << c.day
                 << " " << c.start << "-" << c.end << "\n";
        }
        cout << "--------------------------\n";
    }

    return 0;
}




